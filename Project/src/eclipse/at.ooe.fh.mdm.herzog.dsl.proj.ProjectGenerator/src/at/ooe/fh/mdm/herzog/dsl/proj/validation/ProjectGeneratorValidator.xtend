/*
 * generated by Xtext 2.10.0
 */
package at.ooe.fh.mdm.herzog.dsl.proj.validation

import at.ooe.fh.mdm.herzog.dsl.proj.projectGenerator.JpaConfig
import at.ooe.fh.mdm.herzog.dsl.proj.projectGenerator.Localized
import at.ooe.fh.mdm.herzog.dsl.proj.projectGenerator.Module
import at.ooe.fh.mdm.herzog.dsl.proj.projectGenerator.Observer
import at.ooe.fh.mdm.herzog.dsl.proj.projectGenerator.ProjectGeneratorPackage
import at.ooe.fh.mdm.herzog.dsl.proj.projectGenerator.ServiceConfig
import java.util.Objects
import java.util.regex.Pattern
import org.eclipse.xtext.validation.Check

import static java.util.stream.Collectors.*
import java.util.List
import at.ooe.fh.mdm.herzog.dsl.proj.projectGenerator.LocalizedEntry

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ProjectGeneratorValidator extends AbstractProjectGeneratorValidator {

	/**
	 * The Class holding the validator ids.
	 */
	public static class ValidatorId {
		// Module
		public static final String MODULE_EMPTY = "MODULE_EMPTY";
		public static final String MODULE_NAME_CAMEL_CASE = "MODULE_NAME_CAMEL_CASE";
		public static final String MODULE_KEY_UPPER_CASE = "MODULE_KEY_UPPER_CASE";
		public static final String MODULE_OBSERVER_UNUSED = "MODULE_OBSERVER_UNUSED";
		public static final String MODULE_LOCALIZED_UNUSED = "MODULE_LOCALIZED_UNUSED";
		// Observer
		public static final String OBSERVER_NAME_CAMEL_CASE = "OBSERVER_NAME_CAMEL_CASE";
		public static final String OBSERVER_NAME_DUPLICATE = "OBSERVER_NAME_UNIQUE";
		// Localized
		public static final String LOCALIZED_NAME_CAMEL_CASE = "LOCALIZED_NAME_CAMEL_CASE";
		public static final String LOCALIZED_NAME_DUPLICATE = "LOCALIZED_NAME_UNIQUE";
		public static final String LOCALIZED_ENTRY_DUPLICATE = "LOCALIZED_ENTRY_DUPLICATE";
		public static final String LOCALIZED_ENTRY_LOCALE_DUPLICATE = "LOCALIZED_ENTRY_LOCALE_DUPLICATE";
		public static final String LOCALIZED_ENTRY_UNDEFINED = "LOCALIZED_ENTRY_UNDEFINED";
		// ServiceConfig
		public static final String SERVICE_CONFIG_MESSAGE_BUNDLE_DUPLICATE = "SERVICE_CONFIG_MESSAGE_BUNDLE_DUPLICATE";
		public static final String SERVICE_CONFIG_OBSERVERS_DUPLICATE = "SERVICE_CONFIG_OBSERVERS_DUPLICATE";
		// JpaConfig
		public static final String JPA_LOCALIZED_ENUMS_DUPLICATE = "JPA_LOCALIZED_ENUMS_DUPLICATE";
		public static final String JPA_OBSERVERS_DUPLICATE = "JPA_OBSERVERS_DUPLICATE";
	}

	static Pattern CAMEL_CASE_PATTERN = Pattern.compile("([A-Z]{1}[a-z0-9]+)+");

	@Check
	def checkForEmptyModule(Module module) {
		if (module.key == null && module.messageBundles.empty && module.observers.empty && module.jpaConfig == null &&
			module.serviceConfig == null) {
			val errorMsg = "Module is empty";
			error(errorMsg, ProjectGeneratorPackage.Literals.MODULE__NAME, ValidatorId.MODULE_EMPTY);
		}
	}

	// Module: Name must be camel case
	@Check
	def checkForCamelCaseModuleName(Module _module) {
		if (!CAMEL_CASE_PATTERN.matcher(_module.name).matches) {
			val errorMsg = "Module name must be a camel case string (e.g.: MyModuleName)";
			error(errorMsg, ProjectGeneratorPackage.Literals.MODULE__NAME, ValidatorId.MODULE_NAME_CAMEL_CASE);
		}
	}

	// Module: Key must be upper case
	@Check
	def checkForUpperCaseModuleKey(Module _module) {
		for (Character c : _module.key.toCharArray) {
			if (Character.isLowerCase(c)) {
				val errorMsg = "Module key must be upper case";
				error(errorMsg, ProjectGeneratorPackage.Literals.MODULE__KEY, ValidatorId.MODULE_KEY_UPPER_CASE);
				return;
			}
		}
	}

	// Module: Observer unused
	@Check
	def checkForUnusedObserver(Module _module) {
		val List<Observer> observers = newArrayList(_module.observers);
		if (_module.serviceConfig != null) {
			observers.removeAll(_module.serviceConfig.observers);
		}
		if (_module.jpaConfig != null) {
			observers.removeAll(_module.jpaConfig.observers);
		}
		if (!observers.isEmpty) {
			val warnMsg = "Some observers are unused";
			warning(warnMsg, ProjectGeneratorPackage.Literals.MODULE__OBSERVERS, ValidatorId.MODULE_OBSERVER_UNUSED,
				observers.stream.map[name].toArray(size|newArrayOfSize(size)));
		}
	}

	// Module: Localized unused
	@Check
	def checkForUnusedMessageBundle(Module _module) {
		val List<Localized> localized = newArrayList(_module.messageBundles);
		if (_module.serviceConfig != null) {
			localized.removeAll(_module.serviceConfig.messageBundles);
		}
		if (_module.jpaConfig != null) {
			localized.removeAll(_module.jpaConfig.localizedEnums);
		}
		if (!localized.isEmpty) {
			val warnMsg = "Some message bundles are unused";
			warning(warnMsg, ProjectGeneratorPackage.Literals.MODULE__MESSAGE_BUNDLES, ValidatorId.MODULE_LOCALIZED_UNUSED,
				localized.stream.map[name].toArray(size|newArrayOfSize(size)));
		}
	}

	// Localized: Name must be camel case
	@Check
	def checkForCamelCaseLocalizedName(Localized _localized) {
		if (!CAMEL_CASE_PATTERN.matcher(_localized.name).matches) {
			val errorMsg = "Localized name must be a camel case string (e.g.: MyLocalizedName)";
			error(errorMsg, ProjectGeneratorPackage.Literals.LOCALIZED__NAME, ValidatorId.LOCALIZED_NAME_CAMEL_CASE);
		}
	}

	// Localized: Name must be unique
	@Check
	def checkForUniqueLocalizedName(Localized _localized) {
		val module = _localized.eContainer as Module;
		Objects.requireNonNull(module, "eContainer should be an instance of Module");
		val count = module.messageBundles.stream.filter[name.equals(_localized.name)].distinct.count;
		if (count > 1) {
			val errorMsg = "Localized name is used by '" + (count - 1) + "' other Localized instances";
			error(errorMsg, ProjectGeneratorPackage.Literals.LOCALIZED__NAME, ValidatorId.LOCALIZED_ENTRY_DUPLICATE);
		}
	}

	// Localized: must contain at least one localized entry
	@Check
	def checkForDefinedLocaleEntries(Localized localized) {
		if (localized.values.empty) {
			error("If attribute 'values' is defined, then at least one localized values must be given",
				ProjectGeneratorPackage.Literals.LOCALIZED__VALUES, ValidatorId.LOCALIZED_ENTRY_UNDEFINED);
		}
	}

	// LocalizedEntry: Duplicate locale entries for a localized key not allowed
	@Check
	def checkForDuplicateLocaleEntries(Localized _localized) {
		val duplicateEntries = _localized.values.stream.collect(groupingBy[localizedKey]).entrySet.stream.filter [
			value.size > 1
		].map[key].distinct.collect(toList);

		if (!duplicateEntries.empty) {
			val errorMsg = "Duplicate locale entries found. " + duplicateEntries.stream.collect(joining(",", "[", "]"));
			error(errorMsg, ProjectGeneratorPackage.Literals.LOCALIZED__VALUES, ValidatorId.LOCALIZED_ENTRY_DUPLICATE,
				duplicateEntries.toArray(newArrayOfSize(duplicateEntries.size)));
		}
	}

	// LocalizedEntry: Duplicate locale entries for a locale not allowed
	@Check
	def checkForDuplicateLocaleEntriesLocales(LocalizedEntry _localized) {
		val duplicateLocales = _localized.values.stream.collect(groupingBy[locale.toString]).entrySet.stream.filter [
			value.size > 1
		].map[key].distinct.collect(toList);

		if (!duplicateLocales.isEmpty) {
			val errorMsg = "Duplicate locale found. " + duplicateLocales.stream.collect(joining(",", "[", "]"));
			error(errorMsg, ProjectGeneratorPackage.Literals.LOCALIZED_ENTRY__VALUES, ValidatorId.LOCALIZED_ENTRY_LOCALE_DUPLICATE,
				duplicateLocales.toArray(newArrayOfSize(duplicateLocales.size)));
		}
	}
	

	// Observer: Name must be camel case
	@Check
	def checkForCamelCaseObserverName(Observer _observer) {
		if (!CAMEL_CASE_PATTERN.matcher(_observer.name).matches) {
			val errorMsg = "Observer name must be a camel case string (e.g.: MyObserverName)";
			error(errorMsg, ProjectGeneratorPackage.Literals.OBSERVER__NAME, ValidatorId.OBSERVER_NAME_CAMEL_CASE);
		}
	}

	// Observer: Name must be unique
	@Check
	def checkForUniqueObserverName(Observer _observer) {
		val module = _observer.eContainer as Module;
		Objects.requireNonNull(module, "eContainer should be an instance of Module");
		val count = module.observers.stream.filter[name.equals(_observer.name)].distinct.count;
		if (count > 1) {
			val errorMsg = "Observer name is used by '" + (count - 1) + "' other Observer instances";
			error(errorMsg, ProjectGeneratorPackage.Literals.OBSERVER__NAME, ValidatorId.OBSERVER_NAME_DUPLICATE);
		}
	}

	// ServiceConfig: Message Bundles must be unique
	@Check
	def checkForUniqueServiceConfigMessageBundles(ServiceConfig _serviceConfig) {
		val duplciateBundles = _serviceConfig.messageBundles.stream.collect(groupingBy[name]).entrySet.stream.filter [
			value.size > 1
		].map[key].distinct.collect(toList);
		if (!duplciateBundles.empty) {
			val errorMsg = "Duplicate message bundles found. " +
				duplciateBundles.stream.collect(joining(",", "[", "]"));
			error(errorMsg, ProjectGeneratorPackage.Literals.SERVICE_CONFIG__MESSAGE_BUNDLES,
				ValidatorId.SERVICE_CONFIG_MESSAGE_BUNDLE_DUPLICATE,
				duplciateBundles.toArray(newArrayOfSize(duplciateBundles.size)));
		}
	}

	// ServiceConfig: Observers must be unique
	@Check
	def checkForUniqueServiceConfigObservers(ServiceConfig _serviceConfig) {
		val duplciateBundles = _serviceConfig.observers.stream.collect(groupingBy[name]).entrySet.stream.filter [
			value.size > 1
		].map[key].distinct.collect(toList);
		if (!duplciateBundles.empty) {
			val errorMsg = "Duplicate observers found. " +
				duplciateBundles.stream.collect(joining(",", "[", "]"));
			error(errorMsg, ProjectGeneratorPackage.Literals.SERVICE_CONFIG__OBSERVERS,
				ValidatorId.SERVICE_CONFIG_OBSERVERS_DUPLICATE,
				duplciateBundles.toArray(newArrayOfSize(duplciateBundles.size)));
		}
	}

	// JpaConfig: Message Bundles must be unique
	@Check
	def checkForUniqueJpaConfigMessagebundles(JpaConfig _jpaConfig) {
		val duplciateBundles = _jpaConfig.localizedEnums.stream.collect(groupingBy[name]).entrySet.stream.filter [
			value.size > 1
		].map[key].distinct.collect(toList);
		if (!duplciateBundles.empty) {
			val errorMsg = "Duplicate localized enums found. " +
				duplciateBundles.stream.collect(joining(",", "[", "]"));
			error(errorMsg, ProjectGeneratorPackage.Literals.JPA_CONFIG__LOCALIZED_ENUMS,
				ValidatorId.JPA_LOCALIZED_ENUMS_DUPLICATE,
				duplciateBundles.toArray(newArrayOfSize(duplciateBundles.size)));
		}
	}
	
	// JpaConfig: Name must be unique
	@Check
	def checkForUniqueJpaConfigObserverName(JpaConfig _jpaConfig) {
		val duplciateBundles = _jpaConfig.observers.stream.collect(groupingBy[name]).entrySet.stream.filter [
			value.size > 1
		].map[key].distinct.collect(toList);
		if (!duplciateBundles.empty) {
			val errorMsg = "Duplicate observers found. " +
				duplciateBundles.stream.collect(joining(",", "[", "]"));
			error(errorMsg, ProjectGeneratorPackage.Literals.JPA_CONFIG__OBSERVERS,
				ValidatorId.JPA_OBSERVERS_DUPLICATE,
				duplciateBundles.toArray(newArrayOfSize(duplciateBundles.size)));
		}
	}
}
