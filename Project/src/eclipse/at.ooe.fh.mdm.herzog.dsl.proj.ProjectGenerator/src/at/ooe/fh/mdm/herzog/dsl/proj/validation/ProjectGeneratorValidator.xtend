/*
 * generated by Xtext 2.10.0
 */
package at.ooe.fh.mdm.herzog.dsl.proj.validation

import org.eclipse.xtext.validation.Check
import at.ooe.fh.mdm.herzog.dsl.proj.projectGenerator.Localized
import at.ooe.fh.mdm.herzog.dsl.proj.projectGenerator.LocalizedEntry
import at.ooe.fh.mdm.herzog.dsl.proj.projectGenerator.Module
import at.ooe.fh.mdm.herzog.dsl.proj.projectGenerator.ProjectGeneratorPackage
import static java.util.stream.Collectors.*
import java.util.regex.Pattern
import org.eclipse.xtext.validation.AbstractDeclarativeValidator

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ProjectGeneratorValidator extends AbstractProjectGeneratorValidator {

	/**
	 * The Class holding the validator ids.
	 */
	public static class ValidatorId {
		public static final String MODULE_NAME_CAMEL_CASE = "MODULE_NAME_CAMEL_CASE";
		public static final String MODULE_KEY_UPPER_CASE = "MODULE_KEY_UPPER_CASE";
		public static final String DUPLICATE_LOCALIZED_ENTRY = "DUPLICATE_LOCALIZED_ENTRY";
		public static final String DEFINED_LOCALIZED_ENTRY = "DEFINED_LOCALIZED_ENTRY";
	}

	static Pattern CAMEL_CASE_PATTERN = Pattern.compile("([A-Z]{1}[a-z]+)+");

	// 1. Module Name must be camel case
	@Check
	def checkForCamelCaseModuleName(Module _module) {
		if (!CAMEL_CASE_PATTERN.matcher(_module.name).matches) {
			val errorMsg = "Module name must be a camel case string (e.g.: MyModuleName)";
			error(errorMsg, ProjectGeneratorPackage.Literals.MODULE__NAME, ValidatorId.MODULE_NAME_CAMEL_CASE);
		}
	}

	// 2. Module Key must be upper case
	@Check
	def checkForUpperCaseModuleKey(Module _module) {
		for (Character c : _module.key.toCharArray) {
			if (Character.isLowerCase(c)) {
				val errorMsg = "Module key must be upper case";
				error(errorMsg, ProjectGeneratorPackage.Literals.MODULE__KEY, ValidatorId.MODULE_KEY_UPPER_CASE);
				return;
			}
		}
	}

	// 3. Duplicate locale entries for a localized key not allowed
	@Check
	def checkForDuplicateLocaleEntries(LocalizedEntry _localizedEntry) {
		val count = _localizedEntry.values.size;
		val localeCount = _localizedEntry.values.stream.map[locale].distinct.count;
		val duplicateLocales = _localizedEntry.values.stream.collect(groupingBy[locale]).entrySet.stream.filter [
			value.size > 1
		].map[key].distinct.collect(toList);

		if (count != localeCount) {
			val errorMsg = "Duplicate locale entries found. " +
				duplicateLocales.stream.map[toString].collect(joining(",", "[", "]"));
			error(errorMsg, ProjectGeneratorPackage.Literals.LOCALIZED_ENTRY__VALUES, ValidatorId.DUPLICATE_LOCALIZED_ENTRY, duplicateLocales.toArray(newArrayOfSize(duplicateLocales.size)));
		}
	}

	// 4. Localized must contain at least one localized entry
	@Check
	def checkForDefinedLocaleEntries(Localized localized) {
		if (localized.values.empty) {
			error("If attribute 'values' is defined, then at least one localized values must be given",
				ProjectGeneratorPackage.Literals.LOCALIZED__VALUES, ValidatorId.DEFINED_LOCALIZED_ENTRY);
		}
	}
}
